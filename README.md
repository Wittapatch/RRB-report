# Table of Contents
- [Table of Contents](#table-of-contents)
    - [Project's Objective](#projects-objective)
    - [Description of input and output](#description-of-input-and-output)
    - [Libraries Used](#libraries-used)
    - [Relevant References](#relevant-references)
    - [Running the code requirements](#requirements-before-running-the-code)
    - [Explanation of code](#explaination-of-code)

# Project's Objective 
>*Create a Recipe Recommender Bot that reccommends meals or desserts for the user with ingredients and step by step instructions*

# Description of Input and Output

## Function Descriptions for Login, Signup, and Admin

## 1. Login

### Input:

- **Username**: In string format
- **Password**: In string format

### Output:

- **Error message**:

  - *"Please fill in the blanks"* if either the username or password is empty.

  - *"Your account does not exist"* if the username entered does not match any records in the `all_accounts` table database.

  - *"Wrong password"* if the username exists but the entered password is incorrect.
  
- **Success message**:
  - *"Login successful"* if the username and password match.

### Summary:

- If login is successful, the RRB Bot is triggered

---

## 2. Signup

### Input:
- **Username**: In string format
- **Password**: In string format

### Output:

- **Error message**:

  - *"Please fill in the blanks"* if either the username or password is empty.

  - *"Account already exists"* if the entered username already exists in the database.
  
- **Success message**:

  - *"Account created"* if the username is unique, and the account is successfully created.

### Summary:

- After the user account is created, the user's account data is added to the `all_accounts` table in the database with the provided username and password.

---

## 3. Admin

### Input

- **Account ID**:

  - **Delete ID**: String(numeric ID)

### Output

- **Database Check**:

  - The system will check whether the provided account ID exists in the `all_accounts` table.

  - **If the account exists**: The account will be deleted from the database.
  
  - **If the account does not exist**: A message box will appear informing the admin that the account ID was not found.
  
- **Messages**:

  - **"Account deleted successfully"**: If the account with the provided ID was found and deleted.

  - **"Account ID not found"**: If no account with the given ID exists in the database.

---

## RRB bot

### **Input:**

1. **User Speech Input (Voice Recognition):**
   - The bot listens to the user's speech by pressing the **"S" key** through a microphone.
   - Once the user click the **"D" key** the bot will stop listening to the user.
   - The user can speak in **English** or **Thai**, depending on the language mode.
   - The speech is recognized using the **speech_recognition** library.
   - If the user speaks in a language that the bot doesn't currently support, it will inform the user and ask for the user to speak in the correct language.
   - The bot listens for the user to provide ingredients, ask for recipe suggestions, or anything related to cooking.

2. **Language Mode Switch:**
   - The user can press the **"L" key** to switch between **English** and **Thai** language modes.
   - The bot's language settings are adjusted, and it will interpret and respond in the selected language.

### **Output:**

1. **Chat Window Display:**
   - The bot's responses, both in text and voice, are displayed in a **scrollable text window**.
   - Responses generated by the bot are based on the user's input (For example, recipe suggestions, instructions, or friendly conversation).

2. **Voice Output (Text-to-Speech):**
   - The bot speaks its response out using **gTTS (Google Text-to-Speech)** library.
   - The speech is played using the **pygame** library mixer.
   - If the user provides input in **English**, the bot responds in English.
   - If the user provides input in **Thai**, the bot responds in Thai.

3. **Error Messages:**
   - If the bot fails to recognize speech or encounters an error, it will display a message in the chat window and inform the user with voice. For instance, "Sorry, I didn't catch that." or "I don't understand mixed language inputs.".

4. **Language Mode Confirmation:**
   - After switching languages, the bot will display a message confirming the change which are "Language switched to Thai." or "Language switched to English." Both displays are in the chat window and through voice output.


# Summary Table

| **Function**     | **Input**                                       | **Output**                                                   | **Functionality**                                                        |
|------------------|-------------------------------------------------|--------------------------------------------------------------|---------------------------------------------------------------------------|
| **Login**        | - Username (string) <br> - Password (string)    | - Error: *"Please fill in the blanks"* <br> *"Your account does not exist"* <br> *"Wrong password"* <br> - Success: *"Login successful"* | - Authenticates user who has an account <br> - Triggers RRB Bot    |
| **Signup**       | - Username (string) <br> - Password (string)    | - Error: *"Please fill in the blanks"* <br> *"Account already exists"* <br> - Success: *"Account created"* | - Adds new user to `all_accounts` table  |
| **Admin**        | - Account ID (numeric string)                   | - Error: *"Account ID not found"* <br> - Success: *"Account deleted successfully"* | - Deletes user account from database based on ID |
| **RRB Bot**      | - User Speech Input (Voice Recognition) <br> - Language Mode (English/Thai) | - Text output in a scrollable window <br> - Voice output using gTTS <br> - Error message: *"Sorry, I didn't catch that"* | - Provides cooking-related responses <br> - Supports English/Thai language switching |

# Libraries used

## Libraries Used in the Application

1. **os**: Helps your code interact with your computer’s files and programs.

2. **google.generativeai**: Connects your code to Google's AI for generating text and ideas.

3. **speech_recognition**: Listens to audio and turns it into text.

4. **tkinter**: Lets you build app windows with buttons and text boxes.

5. **dotenv**: Safely stores passwords and keys for your program.

6. **PIL (Pillow)**: Edits and works with images in Python.

7. **sqlite3**: Stores and manages data in a simple database.

8. **gTTS**: Converts written text into spoken audio.

9. **deep_translator**: Translates text between languages.

10. **time**: Controls time-related functions like delays and timers.

11. **pygame**: Play audio files.

12. **tempfile**: Creates temporary files for short-term use.

13. **threading**: Runs different parts of your code at the same time.

14. **re**: Finds and matches patterns in text.


# Relevant References
1. [Speech Recognition in Python](https://www.youtube.com/watch?v=9GJ6XeB-vMg&t=238s)
2. [TEXT TO SPEECH IN PYTHON | Convert Text to Speechin Python](https://www.youtube.com/watch?v=_Q8wtPCyMdo&t=420s)
3. [Tkinter Course - Create Graphic User Interfaces in Python Tutorial](https://www.youtube.com/watch?v=YXPyB4XeYLA)
4. [How to Use the Gemini API with Python - Build a Customizable AI Chatbot](https://www.youtube.com/watch?v=CaxPa1FuHx4&t=435s)
5. [How to Play Audio Files (Sound Effects and Music) in Python Using Pygame (Mp3 and Others)](https://www.youtube.com/watch?v=xdkY6yhEccA)
6. [Python Threading Explained in 8 Minutes](https://www.youtube.com/watch?v=A_Z1lgZLSNc)
7. [CS50P - Lecture 7 - Regular Expressions](https://www.youtube.com/watch?v=hy3sd9MOAcc)
8. [The CORRECT way to work with temporary files in Python](https://www.youtube.com/watch?v=mBo6Wuc1Riw&t=365s)

# Requirements before running the code

**First we have to install a virtual environment in our terminal you copy the command below**

**Second we have to install the libraries**
*You have to go in your terminal and write down*

```python
pip install google-generativeai speechrecognition python-dotenv pillow gtts deep-translator pygame PyAudio
```

*If you use MacOs you can write down*

```python
pip3 install google-generativeai speechrecognition python-dotenv pillow gtts deep-translator pygame PyAudio
```

*But, sometimes there is an error when installing the PyAudio on MacOs so what you need to do first is*

- copy and paste this in your terminal:
```python
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```
- then run `brew install portaudio` and then run `pip install pyaudio` and that should work

**Once you have installed the library follow this link to get your gemini API key and place it in your .env file in the venv folder to the variable called `GEMINI_API_KEY`**

#### Here are two links for steps on how to get the API KEY
- [Youtube video on how to get Gemini API KEY](https://www.youtube.com/watch?v=o8iyrtQyrZM)
- [How to get your Gemini API key (5 steps)](https://www.merge.dev/blog/gemini-api-key)


**You can run the code once you have finished the steps :)**

# Explaination of code
- [create_table()](#create_table-function)
- [main_page()](#main_page-function)
    - **Reference for login(), signup() and admin()** [Tkinter Course - Create Graphic User Interfaces in Python Tutorial](https://www.youtube.com/watch?v=YXPyB4XeYLA)
        - [login()](#login-function)
            - [show_password()](#show_password-function)
            - [submit_login()](#submit_login-function)
        - [signup()](#signup-function)
            - [show_password()](#show_password-function)
            - [submit_signup()](#submit_signup-function)
        - [admin()](#admin-function)
            - [show_records()](#show_records-function)
            - [delete_account()](#delete_account-function)
    - **Reference** [How to Use the Gemini API with Python - Build a Customizable AI Chatbot](https://www.youtube.com/watch?v=CaxPa1FuHx4&t=435s)
        - [cook_bot()](#cook_bot-function)
            - **Reference** [Speech Recognition in Python](https://www.youtube.com/watch?v=9GJ6XeB-vMg&t=238s)
                - [recognize_speech()](#recognize_speech-function)
                - **Reference** [Python Threading Explained in 8 Minutes](https://www.youtube.com/watch?v=A_Z1lgZLSNc)
                    - [recognize_speech_start()](#recognize_speech_start-function)
                    - [recognize_speech_stop()](#recognize_speech_stop-function)
            - **Reference** [TEXT TO SPEECH IN PYTHON | Convert Text to Speechin Python](https://www.youtube.com/watch?v=_Q8wtPCyMdo&t=420s) **and** [How to Play Audio Files (Sound Effects and Music) in Python Using Pygame (Mp3 and Others)](https://www.youtube.com/watch?v=xdkY6yhEccA) **and** [The CORRECT way to work with temporary files in Python](https://www.youtube.com/watch?v=mBo6Wuc1Riw&t=365s)
                - [speak()](#speak-function)
            - **Reference** [CS50P - Lecture 7 - Regular Expressions](https://www.youtube.com/watch?v=hy3sd9MOAcc)
                - [is_thai()](#is_thai-function)
                - [is_english_only()](#is_english_only-function)
                - [is_mixed_language()](#is_mixed_language-function)
            - [get_response()](#get_response-function)
            - [update_chat()](#update_chat-function)
            - [toggle_language()](#toggle_language-function)
            - [exit_program()](#exit_program-function)

## `main_page()` Function
### Summary of this function --> [summary](#summary-2)

```python
    def main_page():

        main = Tk()
        main.geometry("500x500")
        main.configure(bg="white")
        
        # Setting up the logo
        chef_img = ImageTk.PhotoImage(Image.open("chef-bot-image.jpg"))
        Label(main, image=chef_img, bg="white").grid(row=0, column=0)

        # Label for bot name
        Label(main, text="RRB Bot", font=("Helvetica", 18, "bold"), bg="white", fg="#5d5c61").grid(row=1, column=0, pady=10)

        # Buttons for Sign Up, Login, and Admin access
        Button(main, text="Sign Up", command=signup, width=15, bg="#b3cde0", fg="black").grid(row=2, column=0, pady=10)
        Button(main, text="Login", command=login, width=15, bg="#b3cde0", fg="black").grid(row=3, column=0, pady=10)
        Button(main, text="Admin", command=admin, width=15, bg="#f08080", fg="black").grid(row=4, column=0, pady=10)

        # Center buttons in the main window
        main.grid_columnconfigure(0, weight=1)

        main.mainloop()

    main_page()
```

### 1. **Creating the Main Window**
```python
    main = Tk()
    main.geometry("500x500")
    main.configure(bg="white")

    """ rest of the code """

    main.mainloop()
```

- **`Tk()`**:  
  Initializes the main window of the application.

- **`main.geometry("500x500")`**:  
  Sets the window size to 500x500 pixels.

- **`main.configure(bg="white")`**:  
  Changes the background color of the window to white.

- **`main.mainloop()`**:  
  Starts the main event loop, keeping the window open until the user interacts with it 
### 2. Logo

```python
    # Setting up the logo
    chef_img = ImageTk.PhotoImage(Image.open("chef-bot-image.jpg"))
    Label(main, image=chef_img, bg="white").grid(row=0, column=0)

    # Label for bot name
    Label(main, text="RRB Bot", font=("Helvetica", 18, "bold"), bg="white", fg="#5d5c61").grid(row=1, column=0, pady=10)
```

- **`Label(main, image=chef_img, bg="white")`**:  
  Creates a label widget that displays the image (`chef_img`) and positions it at row 0, column 0 in the window using `.grid()`.

- **`Label(main, text="RRB Bot", font=("Helvetica", 18, "bold"), bg="white", fg="#5d5c61")`**:  
  Creates a label with the text "RRB Bot", using the specified font and color, and positions it in row 1, column 0 with padding.

### 3 main buttons: Login, Signup and Admin

```python
    # Buttons for Sign Up, Login, and Admin access
    Button(main, text="Sign Up", command=signup, width=15, bg="#b3cde0", fg="black").grid(row=2, column=0, pady=10)
    Button(main, text="Login", command=login, width=15, bg="#b3cde0", fg="black").grid(row=3, column=0, pady=10)
    Button(main, text="Admin", command=admin, width=15, bg="#f08080", fg="black").grid(row=4, column=0, pady=10)

    # Center buttons in the main window
    main.grid_columnconfigure(0, weight=1)
```

- **`Button(main, text="Sign Up", command=signup, width=15, bg="#b3cde0", fg="black")`**:  
  Creates a button for signing up with a label "Sign Up". The `command=signup` links the button to a function called [signup()](#signup-function). Similarly, buttons for "Login" and "Admin" are created.

- **`main.grid_columnconfigure(0, weight=1)`**:  
  Configures the grid to center the buttons within the window by giving column 0 weight 1. This means the column expands to take up all available space.

### Summary
The `main_page()` function creates a main window where users can see the 3 buttons: 1. signup 2.login 3.admin which they can interact by simply clicking the button and it will proceed to the function that they triggered by the button.

## `login()` Function
### Summary of this function --> [summary](#summary-3)

```python
    def login():
        global username, password
        login_page = Toplevel()
        login_page.geometry("400x300")
        login_page.title("Login")
        login_page.configure(bg="#f0f8ff")

        # Create and place widgets for username and password entry
        Label(login_page, text="Username:", bg="#f0f8ff").grid(row=0, column=0, padx=10, pady=10)
        username = Entry(login_page, width=30)
        username.grid(row=0, column=1, padx=10, pady=10)
        Label(login_page, text="Password:", bg="#f0f8ff").grid(row=1, column=0, padx=10, pady=10)
        password = Entry(login_page, width=30, show="*")
        password.grid(row=1, column=1, padx=10, pady=10)

        # Add the show password option and the login button
        Checkbutton(login_page, text="Show password", command=show_password, bg="#f0f8ff").grid(row=2, column=1, pady=5)
        Button(login_page, text="Login", command=submit_login, bg="#b3cde0", fg="black").grid(row=3, column=1, pady=10)
```

### Create window

```python
    global username, password
    login_page = Toplevel()
    login_page.geometry("400x300")
    login_page.title("Login")
    login_page.configure(bg="#f0f8ff")
```

#### `global username, password`
This declares the variables `username` and `password` as global variables, so they can be accessed outside of the `login()` function.

#### `login_page = Toplevel()`
This creates a new top-level window (a separate window from the main application window) for the login user interface.

#### `login_page.geometry("400x300")`
Sets the size of the login window to 400 pixels wide and 300 pixels tall.

#### `login_page.title("Login")`
Gives the window a title of "Login" that appears at the top of the window.

#### `login_page.configure(bg="#f0f8ff")`
Sets the background color of the login window to a light blue color (`#f0f8ff`).

## Username and Password entry

```python
    # Create and place widgets for username and password entry
    Label(login_page, text="Username:", bg="#f0f8ff").grid(row=0, column=0, padx=10, pady=10)
    username = Entry(login_page, width=30)
    username.grid(row=0, column=1, padx=10, pady=10)
    Label(login_page, text="Password:", bg="#f0f8ff").grid(row=1, column=0, padx=10, pady=10)
    password = Entry(login_page, width=30, show="*")
    password.grid(row=1, column=1, padx=10, pady=10)
```

#### `Label(login_page, text="Username:", bg="#f0f8ff").grid(row=0, column=0, padx=10, pady=10)`
This creates a label that asks for the "Username", with the same background color as the window. It is placed at row 0, column 0 of the grid layout with padding on both sides (10 pixels).

#### `username = Entry(login_page, width=30)`
Creates an entry widget where the user can type in their username. The width is set to 30 characters.

#### `username.grid(row=0, column=1, padx=10, pady=10)`
Places the username entry widget next to the "Username" label at row 0, column 1 of the grid.

#### `Label(login_page, text="Password:", bg="#f0f8ff").grid(row=1, column=0, padx=10, pady=10)`
Creates a label asking for the "Password" with the same background color, placed in row 1, column 0 of the grid layout.

#### `password = Entry(login_page, width=30, show="*")`
Creates an entry widget for the user to type in their password. The `show="*"` hides the entered characters (commonly used for passwords).

#### `password.grid(row=1, column=1, padx=10, pady=10)`
Places the password entry widget next to the "Password" label in row 1, column 1 of the grid.

## Features
```python
    # Add the show password option and the login button
    Checkbutton(login_page, text="Show password", command=show_password, bg="#f0f8ff").grid(row=2, column=1, pady=5)
    Button(login_page, text="Login", command=submit_login, bg="#b3cde0", fg="black").grid(row=3, column=1, pady=10)
```

#### `Checkbutton(login_page, text="Show password", command=show_password, bg="#f0f8ff").grid(row=2, column=1, pady=5)`
Adds a checkbutton that allows the user to toggle showing the password. When checked, the password will be visible. The `command=show_password` links it to a function called [show_password()](#show_password-function).

#### `Button(login_page, text="Login", command=submit_login, bg="#b3cde0", fg="black").grid(row=3, column=1, pady=10)`
Creates a "Login" button. When clicked, it will call the [submit_login()](#submit_login-function) function. The button is placed at row 3, column 1 of the grid.

### Summary
The `login()` function creates a new window where the user can input their username and password. It also allows them to toggle password visibility and submit the login information with a button.

## `show_password()` Function
### Summary of this function --> [summary](#summary-4)

```python
    def show_password():
        # Toggle the visibility of the password field
        if password.cget("show") == "*":
            password.config(show="")  # Show password
        else:
            password.config(show="*")  # Hide password
```

#### `if password.cget("show") == "*":`
This checks whether the password input field is currently hiding the password (indicated by `show="*"`). The `.cget("show")` method retrieves the current value of the `show` attribute of the `password` entry widget.

#### `password.config(show="")`
If the condition is true (meaning the password is currently hidden), this line updates the `show` attribute of the `password` entry widget to an empty string (`""`), which reveals the password text.

#### `else:`
If the password is not hidden (the `show` attribute is not `"*"`), this block will execute.

#### `password.config(show="*")`
This line sets the `show` attribute of the `password` entry widget back to `"*"`, which hides the password text with the `*` character.

### Summary
The `show_password()` function provides privacy to the user's password whether they want to show their password display when they are typing or not by simply checking the box to turn on and off visibility.

## `submit_login()` Function
### Summary of this function --> [summary](#summary-5)

```python
    def submit_login():
        conn = sqlite3.connect("accounts.db")
        c = conn.cursor()
        
        c.execute("SELECT *, oid FROM all_accounts")
        datas = c.fetchall()

        all_usernames = [i[0] for i in datas]
        all_passwords = [i[1] for i in datas]

        # Check if either username or password is empty and show error
        if username.get() == "" or password.get() == "":
            messagebox.showerror(title="Error", message="Please fill in the blanks")

        # Check if the entered username is not found in the database and show error
        elif username.get() not in all_usernames:
            username.delete(0, END)
            password.delete(0, END)
            messagebox.showerror(title="Error", message="Your account does not exist")
        
        # Check if the entered password is incorrect for the username and show error
        elif password.get() != all_passwords[all_usernames.index(username.get())]:
            username.delete(0, END)
            password.delete(0, END)
            messagebox.showerror(title="Error", message="Wrong password")

        else:
            # If login is successful, clear fields and show success message
            username.delete(0, END)
            password.delete(0, END)
            messagebox.showinfo(title="Success", message="Login successful")
            cook_bot()

        conn.commit()
        conn.close()
```

### Getting data (initializing the data)

```python
    conn = sqlite3.connect("accounts.db")
    c = conn.cursor()
    
    c.execute("SELECT *, oid FROM all_accounts")
    datas = c.fetchall()

    all_usernames = [i[0] for i in datas]
    all_passwords = [i[1] for i in datas]

    """ rest of the code """

    conn.commit()
    conn.close()
```

#### `conn = sqlite3.connect("accounts.db")`
This establishes a connection to an SQLite database called "accounts.db". If the database does not exist, it will be created.

#### `c = conn.cursor()`
Creates a cursor object that allows the program to interact with the database by executing SQLite queries.

#### `c.execute("SELECT *, oid FROM all_accounts")`
Executes an SQLite query to retrieve all the data from the `all_accounts` table in the database. The `oid` is the unique row ID automatically created by SQLite.

#### `datas = c.fetchall()`
Fetches all the results returned by the query and stores them in the `datas` list. Each item in `datas` represents a row from the database.

#### `all_usernames = [i[0] for i in datas]`
Extracts all the usernames from the `datas` list. This is done by iterating over each row and taking the first element (the username).

#### `all_passwords = [i[1] for i in datas]`
Extracts all the passwords from the `datas` list in a similar as the `all_usernames`, but takes the second element (the password).

#### `conn.commit()`
Commits any changes made to the database.

#### `conn.close()`
Closes the database connection.

### Conditions of submitting the login

```python
    # Validate that both username and password are provided
    if username.get() == "" or password.get() == "":
        messagebox.showerror(title="Error", message="Please fill in the blanks")
    # Check if the username already exists in the database
    elif username.get() in all_usernames:
        username.delete(0, END)
        password.delete(0, END)
        messagebox.showerror(title="Error", message="Account already exists")
    else:
        # If the account is new, insert it into the database
        c.execute("INSERT INTO all_accounts VALUES (:username, :password)",
                  {"username": username.get(), "password": password.get()})
        username.delete(0, END)
        password.delete(0, END)
        messagebox.showinfo(title="Success", message="Account created")
        cook_bot()
```

#### `if username.get() == "" or password.get() == "":`
Checks whether either the username or password fields are empty. If either is empty, an error message is displayed.

#### `messagebox.showerror(title="Error", message="Please fill in the blanks")`
If any of the fields are empty, an error message box is displayed to notify the user to fill in both fields.

#### `elif username.get() not in all_usernames:`
Checks if the entered username is not found in the list of all usernames retrieved from the database.

#### `username.delete(0, END)`
Clears the username field.

#### `password.delete(0, END)`
Clears the password field.

#### `messagebox.showerror(title="Error", message="Your account does not exist")`
If the username is not found in the database, an error message box is shown informing the user that the account doesn't exist.

#### `elif password.get() != all_passwords[all_usernames.index(username.get())]:`
If the entered password doesn't match the password associated with the entered username in the database, an error message is displayed.

#### `messagebox.showerror(title="Error", message="Wrong password")`
Displays an error message when the password is incorrect.

#### `else:`
If the login requirement are correct (means that both the username and password match), the program clears the fields and shows a success message.

#### `messagebox.showinfo(title="Success", message="Login successful")`
Shows a success message indicating that the login was successful.

#### `cook_bot()`
Calls the [cook_bot()](#cook_bot-function) function.

### Summary
The `submit_login` function performs the following steps:
1. Checks if the username and password fields are empty.
2. Verifies if the entered username exists in the database.
3. Compares the entered password with the stored password for that username.
4. Displays appropriate error or success messages depending on the validation outcome.
5. If the login is successful, it clears the fields and calls the [cook_bot()](#cook_bot-function) function to proceed.


## `signup()` Function
### Summary of this function --> [summary](#summary-6)

```python
    def signup():
        global username, password
        signup_page = Toplevel()
        signup_page.geometry("400x300")
        signup_page.title("Sign Up")
        signup_page.configure(bg="#f0f8ff")

        # Create and place widgets for username and password entry
        Label(signup_page, text="Username:", bg="#f0f8ff").grid(row=0, column=0, padx=10, pady=10)
        username = Entry(signup_page, width=30)
        username.grid(row=0, column=1, padx=10, pady=10)
        Label(signup_page, text="Password:", bg="#f0f8ff").grid(row=1, column=0, padx=10, pady=10)
        password = Entry(signup_page, width=30, show="*")
        password.grid(row=1, column=1, padx=10, pady=10)

        # Add the show password option and the signup button
        Checkbutton(signup_page, text="Show password", command=show_password, bg="#f0f8ff").grid(row=2, column=1, pady=5)
        Button(signup_page, text="Sign Up", command=submit_signup, bg="#b3cde0", fg="black").grid(row=3, column=1, pady=10)
```

#### Window layout same as:
[login()](#login-function)
#### Functionality same as:
[show_password()](#show_password-function)

### Summary
The `signup()` function basically creates a window where user's can create their accounts and add them to the database.

## `submit_signup()` Function
### Summary of this function --> [summary](#summary-7)

```python
    def submit_signup():
        conn = sqlite3.connect("accounts.db")
        c = conn.cursor()
        
        c.execute("SELECT *, oid FROM all_accounts")
        datas = c.fetchall()
        all_usernames = [i[0] for i in datas]

        # Validate that both username and password are provided
        if username.get() == "" or password.get() == "":
            messagebox.showerror(title="Error", message="Please fill in the blanks")

        # Check if the username already exists in the database
        elif username.get() in all_usernames:
            username.delete(0, END)
            password.delete(0, END)
            messagebox.showerror(title="Error", message="Account already exists")

        else:
            # If the account is new, insert it into the database
            c.execute("INSERT INTO all_accounts VALUES (:username, :password)",
                    {"username": username.get(), "password": password.get()})
            username.delete(0, END)
            password.delete(0, END)
            messagebox.showinfo(title="Success", message="Account created")

        conn.commit()
        conn.close()
```

### Initializing the data
```python
    conn = sqlite3.connect("accounts.db")
    c = conn.cursor()
    
    c.execute("SELECT *, oid FROM all_accounts")
    datas = c.fetchall()
    all_usernames = [i[0] for i in datas]

    """ rest of the code """

    conn.commit()
    conn.close()
```
#### `c.execute("SELECT *, oid FROM all_accounts")`
Executes an SQLite query to select all data from the `all_accounts` table. The `oid` is the automatically created unique row ID.

#### `datas = c.fetchall()`
Fetches all rows from the `all_accounts` table and stores them in the `datas` list. Each element in `datas` represents a row in the database.

#### `all_usernames = [i[0] for i in datas]`
Extracts all the usernames from the `datas` list. It assumes that the username is the first element in each row (index 0).

#### `conn.commit()`
Commits the changes to the database, ensuring that the new account is saved.

#### `conn.close()`
Closes the database connection after the operation is complete.

### Conditions for submitting the signup

```python
    # Validate that both username and password are provided
    if username.get() == "" or password.get() == "":
        messagebox.showerror(title="Error", message="Please fill in the blanks")

    # Check if the username already exists in the database
    elif username.get() in all_usernames:
        username.delete(0, END)
        password.delete(0, END)
        messagebox.showerror(title="Error", message="Account already exists")

    else:
        # If the account is new, insert it into the database
        c.execute("INSERT INTO all_accounts VALUES (:username, :password)",
                {"username": username.get(), "password": password.get()})
        username.delete(0, END)
        password.delete(0, END)
        messagebox.showinfo(title="Success", message="Account created")
        cook_bot()
```

#### `if username.get() == "" or password.get() == "":`
Checks if either the username or password fields are empty. If any field is empty, the user is prompted to fill in the blanks.

#### `messagebox.showerror(title="Error", message="Please fill in the blanks")`
Displays an error message if the username or password fields are empty.

#### `elif username.get() in all_usernames:`
Checks if the entered username already exists in the database by checking if it is in the `all_usernames` list.

#### `username.delete(0, END)`
Clears the username input field.

#### `password.delete(0, END)`
Clears the password input field.

#### `messagebox.showerror(title="Error", message="Account already exists")`
Displays an error message if the username already exists in the database.

#### `else:`
If the username is not empty and does not already exist in the database, it proceeds to insert the new account.

#### `c.execute("INSERT INTO all_accounts VALUES (:username, :password)", {"username": username.get(), "password": password.get()})`
Inserts the new username and password into the `all_accounts` table. It uses parameterized queries to prevent SQLite injection.

#### `username.delete(0, END)`
Clears the username input field after the account is successfully created.

#### `password.delete(0, END)`
Clears the password input field after the account is successfully created.

#### `messagebox.showinfo(title="Success", message="Account created")`
Displays a success message indicating the account was created successfully.

### Summary
The `submit_signup` function performs the following tasks:
1. Checks if the username and password fields are filled.
2. Verifies if the username already exists in the database.
3. If the username is unique, it inserts the new account into the database.
4. Clears the input fields and displays appropriate success or error messages.

## `admin()` Function
### Summary of this function --> [summary](#summary-8)
```python
    def admin():
        global delete_box, display_area
        admin_page = Toplevel()
        admin_page.geometry("500x500")
        admin_page.title("Admin Panel")
        admin_page.configure(bg="#f0f8ff")

        # Add the title and layout for the admin page
        Label(admin_page, text="Admin - Account Management", font=("Arial", 14, "bold"), bg="#f0f8ff").pack(pady=10)
        display_area = scrolledtext.ScrolledText(admin_page, wrap=WORD, state='disabled', width=50, height=15)
        display_area.pack(pady=10)

        # Add buttons for displaying records and deleting accounts
        Button(admin_page, text="Show Records", command=show_records, bg="#b3cde0", fg="black").pack(pady=5)
        Label(admin_page, text="Delete Account by ID:", bg="#f0f8ff").pack()
        delete_box = Entry(admin_page, width=20)
        delete_box.pack(pady=5)
        Button(admin_page, text="Delete Account", command=delete_account, bg="#f08080", fg="black").pack(pady=5)
```

### Create Window
```python
    global delete_box, display_area
    admin_page = Toplevel()
    admin_page.geometry("500x500")
    admin_page.title("Admin Panel")
    admin_page.configure(bg="#f0f8ff")
```

#### `global delete_box, display_area`
The `global` keyword allows the variables `delete_box` (where the admin can enter an account ID to delete) and `display_area` (the scrolled text area that displays account records) to be accessed outside of the function.

#### `admin_page = Toplevel()`
This line creates a new top-level window (which is a secondary window that will serve as the admin panel)

#### `admin_page.geometry("500x500")`
Sets the size of the admin window to be 500 pixels wide and 500 pixels tall.

#### `admin_page.title("Admin Panel")`
Sets the title of the admin window to "Admin Panel".

#### `admin_page.configure(bg="#f0f8ff")`
Changes the background color of the admin panel window to a light blue shade (`#f0f8ff`).


### Layout of the screen

```python
    # Add the title and layout for the admin page
    Label(admin_page, text="Admin - Account Management", font=("Arial", 14, "bold"), bg="#f0f8ff").pack(pady=10)
    display_area = scrolledtext.ScrolledText(admin_page, wrap=WORD, state='disabled', width=50, height=15)
    display_area.pack(pady=10)
```

#### `Label(admin_page, text="Admin - Account Management", font=("Arial", 14, "bold"), bg="#f0f8ff").pack(pady=10)`
Creates a label widget at the top of the admin window with the text "Admin - Account Management". The font is set to Arial, size 14, and bold. It is also given a background color matching the window (`#f0f8ff`). The label is given padding around it to ensure spacing from other elements.

#### `display_area = scrolledtext.ScrolledText(admin_page, wrap=WORD, state='disabled', width=50, height=15)`
Creates a scrollable text box widget (`ScrolledText`) to display account records. The text box has a width of 50 characters and a height of 15 lines. The `wrap=WORD` ensures that text wraps at word boundaries, and `state='disabled'` makes the text box non-editable (Just for view).

#### `display_area.pack(pady=10)`
Adds the `display_area` widget to the admin window with vertical padding around it to ensure space between the text box and other elements.

# 2 Buttons and 1 Entry

```python
    # Add buttons for displaying records and deleting accounts
    Button(admin_page, text="Show Records", command=show_records, bg="#b3cde0", fg="black").pack(pady=5)
    Label(admin_page, text="Delete Account by ID:", bg="#f0f8ff").pack()
    delete_box = Entry(admin_page, width=20)
    delete_box.pack(pady=5)
    Button(admin_page, text="Delete Account", command=delete_account, bg="#f08080", fg="black").pack(pady=5)
```

#### `Button(admin_page, text="Show Records", command=show_records, bg="#b3cde0", fg="black").pack(pady=5)`
Creates a button labeled "Show Records". When clicked, it calls the [show_records()](#show_records-function) function to display account records in the `display_area` text box. The button has a background color of light blue (`#b3cde0`) and black text color.

#### `Label(admin_page, text="Delete Account by ID:", bg="#f0f8ff").pack()`
This creates a label that prompts the admin to "Delete Account by ID:". It uses the same background color as the admin panel window.

#### `delete_box = Entry(admin_page, width=20)`
Creates an entry widget (a text input field) for the admin to enter the ID of the account they wish to delete. It is 20 characters wide.

#### `delete_box.pack(pady=5)`
Adds the `delete_box` entry widget to the window with some vertical padding to separate it from other widgets.

#### `Button(admin_page, text="Delete Account", command=delete_account, bg="#f08080", fg="black").pack(pady=5)`
Creates a button labelled "Delete Account". When clicked, it calls the [delete_account()](#delete_account-function) function to delete the account whose ID is entered in the `delete_box`. The button is styled with a red background (`#f08080`) and black text.

### Summary
This `admin` function creates a window where an admin can manage user accounts. The features provided include:
- Viewing account records in a non-editable text box (`display_area`).
- A button to show records, triggering the [show_records()](#show_records-function) function.
- A field (`delete_box`) to enter an account ID for deleting.
- A button to delete the account with the entered ID, triggering the [delete_account()](#delete_account-function) function.


## `show_records()` Function
### Summary of this function --> [summary](#summary-9)

```python
    def show_records():
        conn = sqlite3.connect("accounts.db")
        c = conn.cursor()

        c.execute("SELECT *, oid FROM all_accounts")
        records = c.fetchall()

        display_area.config(state='normal')
        display_area.delete('1.0', END)

        # Display the records in the display area (text widget)
        for record in records:
            display_area.insert(END, f"ID: {record[2]} | Username: {record[0]} | Password: {record[1]}\n")
        
        # Disable the text widget to prevent further editing
        display_area.config(state='disabled')

        conn.commit()
        conn.close()
```

#### `conn = sqlite3.connect("accounts.db")`
Establishes a connection to the SQLite database (`accounts.db`) where user account data is stored.

#### `c = conn.cursor()`
Creates a cursor object, `c`, which allows the execution of SQLite commands on the database.

#### `c.execute("SELECT *, oid FROM all_accounts")`
Executes an SQLite query to retrieve all records from the `all_accounts` table in the database, including the unique row ID (`oid`).

#### `records = c.fetchall()`
Fetches all the results of the query as a list of tuples, where each tuple represents a row from the `all_accounts` table.

#### `display_area.config(state='normal')`
Enables the text widget (`display_area`) to allow text insertion, as it was previously set to a disabled state for non-editing purposes.

#### `display_area.delete('1.0', END)`
Deletes all the content in the `display_area` text widget from the first character (`'1.0'`) to the end (`END`). This clears the widget before displaying the new records.

#### `for record in records:`
Iterates through the list of records fetched from the database. Each `record` is a tuple containing data for a user account.

#### `display_area.insert(END, f"ID: {record[2]} | Username: {record[0]} | Password: {record[1]}\n")`
Inserts each record into the `display_area` as a formatted string. The ID, username, and password are extracted from the `record` tuple (with `record[2]` being the `oid`, `record[0]` the username, and `record[1]` the password). Each record is displayed on a new line.

#### `display_area.config(state='disabled')`
After inserting the records, the text widget is disabled again to prevent users from editing the text.

#### `conn.commit()`
Commits the transaction to the database. This ensures that any changes made to the database are saved.

#### `conn.close()`
Closes the connection to the database.

### Summary
The `show_records` function is responsible for retrieving all user account records from the SQLite database and displaying them in the `display_area` text widget. The function:
- Connects to the `accounts.db` database.
- Retrieves all records from the `all_accounts` table.
- Clears the display area and inserts the records in a readable format (ID, username, and password).
- Disables the text widget after displaying the records to prevent editing.

## `delete_account()` Function
### Summary of this function --> [summary](#summary-10)

```python
    def delete_account():
        conn = sqlite3.connect("accounts.db")
        c = conn.cursor()

        # Check if the account ID exists in the database
        c.execute("SELECT * FROM all_accounts WHERE oid = ?", (delete_box.get(),))
        account = c.fetchone()

        if account is None:
            # If no account with the given ID exists, show error message
            messagebox.showerror("Error", "Account ID not found")
        else:
            # If account exists, delete it
            c.execute("DELETE from all_accounts WHERE oid = ?", (delete_box.get(),))
            delete_box.delete(0, END)  # Clear the input box
            conn.commit()  # Commit the change
            messagebox.showinfo("Deleted", "Account deleted successfully")  # Success message

        conn.close()  # Close the database connection
```

#### `conn = sqlite3.connect("accounts.db")`
Establishes a connection to the SQLite database (`accounts.db`) where user account data is stored.

#### `c = conn.cursor()`
Creates a cursor object `c` to execute SQLite queries.

#### `c.execute("SELECT * FROM all_accounts WHERE oid = ?", (delete_box.get(),))`
Executes an SQLite query to check if the account with the `oid` (account ID) entered in the `delete_box` (input field) exists in the `all_accounts` table. The `?` is a placeholder for the parameter, which is securely passed as a tuple with `delete_box.get()`.

#### `account = c.fetchone()`
Fetches the first matching record for the given account ID. If no record is found, `account` will be `None`.

#### `if account is None:`
Checks if the account does not exist in the database.

#### `messagebox.showerror("Error", "Account ID not found")`
If the account doesn't exist, an error message is shown to the user, indicating the account ID wasn't found.

#### `else:`
If the account exists, the following steps below are executed:

#### `c.execute("DELETE from all_accounts WHERE oid = ?", (delete_box.get(),))`
Executes an SQLite query to delete the record with the given account ID from the `all_accounts` table.

#### `delete_box.delete(0, END)`
Clears the input field (`delete_box`) after the deletion.

#### `conn.commit()`
Commits the transaction to the database, saving the deletion of the account.

#### `messagebox.showinfo("Deleted", "Account deleted successfully")`
Shows a success message to inform the user that the account has been deleted.

#### `conn.close()`
Closes the database connection, releasing any resources.

### Summary
The `delete_account` function performs the task of deleting a user account from the database:
- It checks whether the account ID exists in the database.
- If the account exists, it deletes the corresponding record.
- If the account ID is not found, it displays an error message.
- Upon successful deletion, it shows a success message and clears the input field.

## `cook_bot()` Function
```python
    # Initialize language variable (Default as English)
    language = "en"
    is_listening = False
    listening_thread = None

    def cook_bot():
        # Load environment variables .env file to access the API KEY
        load_dotenv()
        # Configure Gemini's generative model with the API KEY
        genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
        # Define the parameters for the AI model's responses
        generation_config = {
            "temperature": 0,  
            "top_p": 0.95,     
            "top_k": 64,       
            "max_output_tokens": 8192,  # Maximum length of the response
            "response_mime_type": "text/plain",  # Response type
        }

        # Initialize the generative model with its specific settings
        model = genai.GenerativeModel(
            model_name="gemini-1.5-pro",  # Model version
            generation_config=generation_config,
            system_instruction="""Your name is RRB. You are a friendly recipe recommendation assistant designed to suggest recipes based on user inputs and preferences.
        Main rule: Avoid using asterisks (*) in your responses. 
        1. When a user provides ingredients they have at home, ask whether they prefer a dessert or a main meal.
        2. Next ask him “What type of cuisine would you like? For example, Thai, Italian, or Indian?”
        3. Generate and present up to one or three recipe ideas that utilize the ingredients they provided.
        4. Each suggestion should include a brief description highlighting the appeal of the dish.
        5. After presenting the ideas, ask the user which recipe they prefer.
        6. Once they choose a recipe, ask if they would like to see the detailed ingredients and step-by-step instructions for that recipe.
        7. If the user responds affirmatively, provide a clear list of ingredients and a concise set of instructions.
        8. Always maintain a friendly, encouraging, and conversational tone. Use simple language to ensure clarity.
        9. If the user expresses uncertainty or asks for more options, reassure them and offer additional recipe suggestions based on their initial ingredients.
        """,  # Instructions to model on how it should behave
        )

        # Initialize an empty history (using a list) to maintain conversation context
        history = []

        # Define a function to get a response from the RRB BOT based on the user's input
        def get_response(user_input):
            chat_session = model.start_chat(history=history)
            response = chat_session.send_message(user_input)
            model_response = response.text
            history.append({"role": "user", "parts": [user_input]})
            history.append({"role": "model", "parts": [model_response]})
            return model_response

        # Define a function to update the chat window with new messages
        def update_chat(message):
            chat_window.configure(state='normal') 
            chat_window.insert(END, message + '\n')  
            chat_window.configure(state='disabled')  
            chat_window.yview(END)  
            chat_window.update_idletasks()  # Force the update to show immediately

        # Define a function to speak the provided text using gTTS (Google Text-to-Speech) library
        def speak(text, lang='th'):
            # Generate speech using gTTS (Google Text-to-Speech)
            # Defining the class (to use the functionalities)
            tts = gTTS(text=text, lang=lang)

            # Create a temporary file for the speech audio
            temp_file_path = None
            try:
                # Save the generated speech as an MP3 file
                with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as temp_file:
                    temp_file_path = temp_file.name
                    tts.save(temp_file_path)

                # Initialize the pygame mixer to play the audio
                pygame.mixer.init()

                # Load and play the generated MP3 file
                pygame.mixer.music.load(temp_file_path)
                pygame.mixer.music.play()

                # Wait for the audio to finish playing before proceeding
                while pygame.mixer.music.get_busy():
                    time.sleep(0.1)  # To avoid waiting too long

            finally:
                # Quit pygame mixer to release resources after playing
                pygame.mixer.quit()

                # Clean up by removing the temporary audio file
                if temp_file_path and os.path.exists(temp_file_path):
                    time.sleep(0.5)  # Add a slight delay before deletion to avoid errors
                    os.remove(temp_file_path)

        def recognize_speech(event=None):
            global is_listening
            recognizer = speech_recognition.Recognizer()  # Initialize the recognizer
            with speech_recognition.Microphone() as mic:
                recognizer.adjust_for_ambient_noise(mic, duration=0.2)  # Adjust for background noise
                update_chat("Listening...")  # Notify user that the bot is listening
                while is_listening:
                    try:
                        # Capture audio from the microphone with a timeout of 1 second
                        audio = recognizer.listen(mic, timeout=1)
                        
                        # Recognize speech and convert it to text based on the language mode
                        if language == 'th':
                            user_input = recognizer.recognize_google(audio, language='th-TH')  # Thai language recognition
                        else:
                            user_input = recognizer.recognize_google(audio, language='en-US')  # English language recognition
                        
                        user_input = user_input.lower()  # Normalize the input to lowercase

                        # Check if the user speaks the wrong language based on the current language mode

                        if language == 'en' and is_thai(user_input):  # User speaks Thai, but language is set to English
                            update_chat("👨‍🍳: Sorry, I don't understand Thai. I only understand English.")
                            speak("Sorry, I don't understand Thai. I only understand English.", lang='en')
                            continue 
                        
                        if language == 'th' and is_english_only(user_input):  # User speaks English, but language is set to Thai
                            update_chat("👨‍🍳: ขอโทษที ฉันไม่เข้าใจภาษาอังกฤษ ฉันเข้าใจแต่ภาษาไทย")
                            speak("ขอโทษที ฉันไม่เข้าใจภาษาอังกฤษ ฉันเข้าใจแต่ภาษาไทย", lang='th')
                            continue

                        # Check if the input is mixed language (both Thai and English)

                        if is_mixed_language(user_input):
                            if language == 'th':
                                translated_response = GoogleTranslator(source='auto', target='th').translate("Sorry, I cannot understand mixed language inputs.")
                                bot_response = translated_response
                            update_chat(f"👨‍🍳: {bot_response}")
                            speak(f"{bot_response}", lang=language)
                            continue  

                        update_chat("You: " + user_input)  # Display the user's input
                        bot_response = get_response(user_input)  # Get the bot's response

                        update_chat("👨‍🍳: " + bot_response)  # Display the bot's response
                        speak(bot_response, lang=language)  # Speak out the bot's response

                    except speech_recognition.WaitTimeoutError:
                        pass  # Continue listening if no speech detected within timeout
                    except speech_recognition.UnknownValueError:
                        update_chat("👨‍🍳: Sorry, I didn't catch that.")  # Handle speech recognition errors
                    except Exception as e:
                        update_chat("Error: " + str(e))  # Handle any other exceptions
                        break

        # Checks if the text contains Thai characters
        def is_thai(text):
            return bool(re.fullmatch('[\u0E00-\u0E7F\\s]+', text))
        
        # Checks if the text contains English characters
        def is_english_only(text):
            return bool(re.fullmatch(r'^[A-Za-z0-9\s,\.!?;:()"\']+$', text))
        
        # Check if the text contains both English and Thai characters
        def is_mixed_language(text):
            has_thai = bool(re.search('[\u0E00-\u0E7F]', text))
            has_english = bool(re.search('[A-Za-z]', text))
            
            return has_thai and has_english  # Returns True if both Thai and English are found

        # Function to start speech recognition when the user presses the "s" key to start
        def recognize_speech_start(event=None):
            global is_listening, listening_thread
            if not is_listening:
                is_listening = True
                listening_thread = threading.Thread(target=recognize_speech)  # Start the speech recognition in a new thread
                listening_thread.start()

        # Function to stop speech recognition when the user releases the "s" key to stop
        def recognize_speech_stop(event=None):
            global is_listening
            if is_listening:
                is_listening = False
                update_chat("Stopped listening.")  # Notify user that listening has stopped

        # Function to toggle between English and Thai language modes
        def toggle_language(event=None):
            global language
            # Switch the language
            if language == "en":
                language = "th"
            else:
                language = "en" 
            # Show a message indicating the language change 
            if language == "th":
                lang_message = "Language switched to Thai."
            else:
                lang_message = "Language switched to English."
            update_chat(lang_message)
            speak(lang_message, lang=language)

        # Function to exit the program when the user presses the exit key
        def exit_program(event=None):
            root.quit()  # Close the Tkinter window
            os._exit(0)  # Exit the program immediately


        # Creating the window for chatbot
        root = Tk()
        root.title("Voice Chatbot")

        # Create a scrollable text widget for the chat window
        chat_window = scrolledtext.ScrolledText(root, state='disabled', wrap=WORD)
        chat_window.pack(pady=10, padx=10)  # Add padding and display the chat window

        # Bind specific keys to actions (start/stop listening, switch language, exit)
        root.bind('<KeyPress-s>', recognize_speech_start)  # Start listening on 's' key press
        root.bind('<KeyRelease-d>', recognize_speech_stop)  # Stop listening on 'd' key press
        root.bind('q', exit_program)  # Press 'q' to exit the program
        root.bind('l', toggle_language)  # Press 'l' to toggle language (English/Thai)

        # Send a greeting message to the chat window and speak it out
        greeting_text = "Hello! I am RRB your cooking assistant bot. What ingredients do you have for me today?"
        update_chat("👨‍🍳: " + greeting_text)
        speak(greeting_text, lang=language)

        root.mainloop()
```

### API Configuration, Initializing the model and system instructions
```python
    # Load environment variables .env file to access the API KEY
    load_dotenv()
    # Configure Gemini's generative model with the API KEY
    genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
    # Define the parameters for the AI model's responses
    generation_config = {
        "temperature": 0,  
        "top_p": 0.95,     
        "top_k": 64,       
        "max_output_tokens": 8192,  # Maximum length of the response
        "response_mime_type": "text/plain",  # Response type
    }

    # Initialize the generative model with its specific settings
    model = genai.GenerativeModel(
        model_name="gemini-1.5-pro",  # Model version
        generation_config=generation_config,
        system_instruction="""Your name is RRB. You are a friendly recipe recommendation assistant designed to suggest recipes based on user inputs and preferences.
    Main rule: Avoid using asterisks (*) in your responses. 
    1. When a user provides ingredients they have at home, ask whether they prefer a dessert or a main meal.
    2. Next ask him “What type of cuisine would you like? For example, Thai, Italian, or Indian?”
    3. Generate and present up to one or three recipe ideas that utilize the ingredients they provided.
    4. Each suggestion should include a brief description highlighting the appeal of the dish.
    5. After presenting the ideas, ask the user which recipe they prefer.
    6. Once they choose a recipe, ask if they would like to see the detailed ingredients and step-by-step instructions for that recipe.
    7. If the user responds affirmatively, provide a clear list of ingredients and a concise set of instructions.
    8. Always maintain a friendly, encouraging, and conversational tone. Use simple language to ensure clarity.
    9. If the user expresses uncertainty or asks for more options, reassure them and offer additional recipe suggestions based on their initial ingredients.
    """,  # Instructions to model on how it should behave
    )
```
#### `load_dotenv()`
This function loads environment variables from a `.env` file into the program's environment. **It helps to manage sensitive information such as API keys without exposing them in the code.**

#### `genai.configure(api_key=os.getenv("GEMINI_API_KEY"))`
This line configures the Gemini AI model by setting the API key. The API key is retrieved securely from the environment variable using `os.getenv("GEMINI_API_KEY")`.

#### `generation_config = {}`
This dictionary defines the settings for the AI model’s response generation. It includes:
- `temperature`: Controls randomness in the model's responses. A value of `0` makes the output accurate.
- `top_p`: Sets the cumulative probability for token sampling (for every api key Google give you around 2,000,000 tokens if you use the Gemini-Pro-1.5).
- `top_k`: Limits the number of tokens to sample from for each word (each word takes different amount of token from you).
- `max_output_tokens`: Defines the maximum number of tokens (words and punctuation) the model can generate in a single response.
- `response_mime_type`: Specifies that the model's response will be in plain text format.

#### `model = genai.GenerativeModel()`
This line initializes the Gemini AI model with the configuration and behavior settings:
- `model_name="gemini-1.5-pro"`: Specifies the version of the Gemini model to use (In the case we using is Gemini-Pro-1.5).
- `generation_config=generation_config`: Passes the response generation settings defined earlier.
- `system_instruction="..."`: Provides detailed behavior instructions, which define how the bot should interact with users. These instructions ensure the bot gives recipe suggestions based on user input, asks questions about the user's preferences, and delivers responses in a friendly and clear manner.

### Summary
The code initializes the Gemini AI model for recipe suggestions:
- It securely loads the API key from an environment file in a virtual environment.
- It configures the model's response behavior with specific settings like response length and accuracy.
- It passes the model detailed instructions on how to assist users with recipe recommendations in a clear, friendly way.

### Creating the RRB bot window

```python  
    # Creating the window for chatbot
    root = Tk()
    root.title("Voice Chatbot")

    # Create a scrollable text widget for the chat window
    chat_window = scrolledtext.ScrolledText(root, state='disabled', wrap=WORD)
    chat_window.pack(pady=10, padx=10)  # Add padding and display the chat window

    # Bind specific keys to actions (start/stop listening, switch language, exit)
    root.bind('<KeyPress-s>', recognize_speech_start)  # Start listening on 's' key press
    root.bind('<KeyRelease-s>', recognize_speech_stop)  # Stop listening on 's' key release
    root.bind('q', exit_program)  # Press 'q' to exit the program
    root.bind('l', toggle_language)  # Press 'l' to toggle language (English/Thai)

    # Send a greeting message to the chat window and speak it out
    greeting_text = "Hello! I am RRB your cooking assistant bot. What ingredients do you have for me today?"
    update_chat("👨‍🍳: " + greeting_text)
    speak(greeting_text, lang=language)

    root.mainloop()
```

#### `root = Tk()`
This line initializes the main window of the chatbot application using Tkinter, a Python library for building GUI applications. `root` will be the container for all UI elements.

#### `root.title("Voice Chatbot")`
This sets the title of the application window to "Voice Chatbot", which will appear at the top of the window.

#### `chat_window = scrolledtext.ScrolledText(root, state='disabled', wrap=WORD)`
This creates a scrollable text widget within the window to display the conversation between the user and the chatbot. The `state='disabled'` makes the text area read-only, preventing the user from editing the chat. The `wrap=WORD` option ensures that the text wraps at word boundaries.

#### `chat_window.pack(pady=10, padx=10)`
This places the `chat_window` widget in the main window with 10 pixels of padding around it (both vertically with `pady` and horizontally with `padx`).

#### `root.bind('<KeyPress-s>', recognize_speech_start)`
This binds the 's' key press event to start speech recognition by calling the [recognize_speech_start()](#recognize_speech_start-function) function, allowing the user to activate the speech recognition when the 's' key is pressed or holded.

#### `root.bind('<KeyRelease-s>', recognize_speech_stop)`
This binds the 's' key release event to stop the speech recognition by calling the [recognize_speech_stop()](#recognize_speech_stop-function) function. The recognition will stop when the 's' key is released.

#### `root.bind('q', exit_program)`
This binds the 'q' key to exit the program by calling the [exit_program()](#exit_program-function) function when the 'q' key is pressed.

#### `root.bind('l', toggle_language)`
This binds the 'l' key to switch between English and Thai languages by calling the [toggle_language](#toggle_language-function) function when the 'l' key is pressed.

#### `greeting_text = "Hello! I am RRB your cooking assistant bot. What ingredients do you have for me today?"`
This defines the initial greeting message that will be shown to the user in the chat window. It introduces the chatbot and asks for the ingredients available to the user.

#### `update_chat("👨‍🍳: " + greeting_text)`
This function call updates the chat window with the greeting message from the bot.

#### `speak(greeting_text, lang=language)`
This function call converts the `greeting_text` into speech and reads it aloud using the [speak](#speak-function) function. The language is determined by the variable `language` (a global variable), which may toggle between English and Thai.

#### `root.mainloop()`
This starts the Tkinter event loop, which keeps the application running and responsive to user actions and listens to any key presses and window events.

### Summary
- The code creates a simple graphical user interface (GUI) for a talking cooking assistant chatbot (RRB Bot).
- It initializes a window with a scrollable text area to display the chat conversation.
- The program binds specific keys ('s' to start/stop listening, 'q' to exit, 'l' to toggle language) to there corresponding the functions.
- A greeting message is displayed and spoken by the bot to engage the user in conversation.
- The `mainloop` keeps the application running and responsive to user input.

## `recognize_speech_start()` Function
### Summary of this function --> [summary](#summary-13)
```python
    # Function to start speech recognition when the user presses the "s" key to start
    def recognize_speech_start(event=None):
        global is_listening, listening_thread
        if not is_listening:
            is_listening = True
            listening_thread = threading.Thread(target=recognize_speech)  # Start the speech recognition in a new thread
            listening_thread.start()
```

#### `global is_listening, listening_thread`
This declares the `is_listening` and `listening_thread` variables as global. This ensures that these variables can be accessed and modified outside the function, maintaining their state across different parts of the program. `is_listening` will track whether the speech recognition is currently active, and `listening_thread` will store the thread handling the `recognize_speech` function.

#### `if not is_listening:`
This checks if the bot is already listening for speech input. If `is_listening` is `False`, it indicates that the bot is not currently recognizing speech, so it can start a new session.

#### `is_listening = True`
Once the function starts `recognize_speech` function, this sets `is_listening` to `True`, indicating that the bot is actively listening for voice input.

#### `listening_thread = threading.Thread(target=recognize_speech)`
This creates a new thread `listening_thread` that will run the `recognize_speech` function. Running speech recognition in a separate thread which allows the main program to continue running without being blocked by the speech recognition process.

#### `listening_thread.start()`
This starts the `listening_thread`, which in turn begins the speech recognition process by invoking the `recognize_speech` function in a separate thread.

### Summary
- The `recognize_speech_start` function is responsible for initiating speech recognition when the user presses the "s" key.
- It checks if the bot is already listening to avoid starting multiple recognition sessions.
- If not, it starts a new thread to handle the speech recognition process using the `recognize_speech` function, allowing the program to continue running at the same time.

## `recognize_speech_stop()` Function
### Summary of this function --> [summary](#summary-14)

```python
    # Function to stop speech recognition when the user releases the "s" key to stop
    def recognize_speech_stop(event=None):
        global is_listening
        if is_listening:
            is_listening = False
            update_chat("Stopped listening.")  # Notify user that listening has stopped
```

#### `global is_listening`
The `global` keyword is used to refer to the `is_listening` variable from the global scope. This allows the function to modify its state, indicating whether the chatbot is actively listening for speech or not.

#### `if is_listening:`
This checks if the bot is currently listening. If `is_listening` is `True`, it means the speech recognition is active, and the function will proceed to stop it (once the `s` key is released).

#### `is_listening = False`
This sets `is_listening` to `False`, which stops the chatbot from listening for voice input. This change ensures that number of attempts to start speech recognition won't be processed again unless you press(hold) the `s` key again.

#### `update_chat("Stopped listening.")`
After stopping the speech recognition, this line updates the chat window to notify the user that the bot has stopped listening. This provides feedback to the user that the action has been completed.

### Summary
- The `recognize_speech_stop` function is responsible for stopping speech recognition when the user releases the "s" key.
- It checks if the bot is currently listening; if so, it changes the state of `is_listening` to `False`.
- The function also updates the chat window to inform the user that the bot has stopped listening for voice input.

## `recognize_speech()` Function
### Summary of this function --> [summary](#summary-15)

```python
    def recognize_speech(event=None):
        global is_listening
        recognizer = speech_recognition.Recognizer()  # Initialize the recognizer
        with speech_recognition.Microphone() as mic:
            recognizer.adjust_for_ambient_noise(mic, duration=0.2)  # Adjust for background noise
            update_chat("Listening...")  # Notify user that the bot is listening
            while is_listening:
                try:
                    audio = recognizer.listen(mic)
                    
                    # Recognize speech and convert it to text based on the language mode
                    if language == 'th':
                        user_input = recognizer.recognize_google(audio, language='th-TH')  # Thai language recognition
                    else:
                        user_input = recognizer.recognize_google(audio, language='en-US')  # English language recognition
                    
                    user_input = user_input.lower()  # Normalize the input to lowercase

                    # Check if the user speaks the wrong language based on the current language mode

                    if language == 'en' and is_thai(user_input):  # User speaks Thai, but language is set to English
                        update_chat("👨‍🍳: Sorry, I don't understand Thai. I only understand English.")
                        speak("Sorry, I don't understand Thai. I only understand English.", lang='en')
                        continue 
                    
                    if language == 'th' and is_english_only(user_input):  # User speaks English, but language is set to Thai
                        update_chat("👨‍🍳: ขอโทษที ฉันไม่เข้าใจภาษาอังกฤษ ฉันเข้าใจแต่ภาษาไทย")
                        speak("ขอโทษที ฉันไม่เข้าใจภาษาอังกฤษ ฉันเข้าใจแต่ภาษาไทย", lang='th')
                        continue

                    # Check if the input is mixed language (both Thai and English)

                    if is_mixed_language(user_input):
                        if language == 'th':
                            translated_response = GoogleTranslator(source='auto', target='th').translate("Sorry, I cannot understand mixed language inputs.")
                            bot_response = translated_response
                        update_chat(f"👨‍🍳: {bot_response}")
                        speak(f"{bot_response}", lang=language)
                        continue 

                    if is_listening == False:
                        update_chat("You: " + user_input)  # Display the user's input
                        bot_response = get_response(user_input)  # Get the bot's response

                        # If the language is Thai then translate the response to Thai
                        if language == 'th':
                            translated_response = GoogleTranslator(source='auto', target='th').translate(bot_response)
                            bot_response = translated_response

                        time.sleep(2)  # Adjust the value to the delay you want in seconds

                        update_chat("👨‍🍳: " + bot_response)  # Display the bot's response
                        speak(bot_response, lang=language)  # Speak out the bot's response


                except speech_recognition.WaitTimeoutError:
                    pass  # Continue listening if no speech detected within timeout
                except speech_recognition.UnknownValueError:
                    update_chat("👨‍🍳: Sorry, I didn't catch that.")  # Handle speech recognition errors
                except Exception as e:
                    update_chat("Error: " + str(e))  # Handle any other exceptions
                    break
```

### Code Explanation

#### `def recognize_speech(event=None):`
This function listens to the user's speech, processes it, and responds based on the language settings. It uses the `speech_recognition` library to capture and recognize speech, handling both English and Thai inputs.

#### `recognizer = speech_recognition.Recognizer()`
Initializes the `Recognizer` object, which is used to capture and process the audio from the microphone.

#### `with speech_recognition.Microphone() as mic:`
Opens the microphone as the audio input source to capture the user's speech.

#### `recognizer.adjust_for_ambient_noise(mic, duration=0.2)`
Adjusts the recognizer to account for ambient noise in the environment, improving the accuracy of speech recognition by setting a 0.2-second duration to calibrate the microphone.

#### `update_chat("Listening...")`
Displays a message in the chat window indicating that the bot is listening for input from the user.

#### `while is_listening:`
The loop continuously listens for speech as long as `is_listening` is set to `True`, enabling ongoing speech recognition until manually stopped.

#### `audio = recognizer.listen(mic)`
Captures the audio input from the microphone. This audio is then processed for speech recognition.

#### `if language == 'th':`
Checks if the current language setting is Thai. If true, the speech is recognized using the (`th-TH`) language model. If not, the English model (`en-US`) is used.

#### `user_input = user_input.lower()`
Normalizes the recognized speech by converting it to lowercase for consistency and easier comparison.

#### Language-Specific Error Checks
- **If the bot is set to English and the user speaks Thai**, it notifies the user that it only understands English.
- **If the bot is set to Thai and the user speaks English**, it informs the user that it only understands Thai.

#### `if is_mixed_language(user_input):`
Checks if the user’s input contains both Thai and English characters. If so, the bot responds with a message indicating it cannot process mixed language inputs.

#### `if is_listening == False:`
Once `is_listening` becomes `False`, it processes the user input and return a response from the bot (down below).

#### `update_chat("You: " + user_input)`
Displays the user's speech input in the chat window for the bot to process.

#### `bot_response = get_response(user_input)`
Calls a function to get a response from the bot based on the recognized user input.

#### `if language == 'th':`
If the current language is Thai, the bot translates its response to Thai using the `GoogleTranslator` function from the `deep_translator` library.

#### `time.sleep(2)`
Adds a 2-second delay before displaying and speaking the bot’s response (to let the code run smooth because if there's no delay there might be some errors).

#### `update_chat("👨‍🍳: " + bot_response)`
Displays the bot's response in the chat window.

#### `speak(bot_response, lang=language)`
Speaks the bot’s response aloud using the [speak()](#speak-function) function, adjusting the language setting accordingly (Thai or English).

#### Exception Handling
- **`speech_recognition.WaitTimeoutError`:** If no speech is detected within the timeout, the program continues listening.
- **`speech_recognition.UnknownValueError`:** If speech is not recognized, the bot notifies the user that it couldn't catch the input.
- **General Errors:** Any other exceptions are caught and displayed in the chat window for troubleshooting.

### Summary
- The `recognize_speech` function listens for speech input, recognizes it based on the language setting, and processes it.
- The bot checks for language consistency and handles mixed language inputs.
- It converts the recognized speech into text, gets a response, and speaks the response back to the user.
- The function includes error handling for unrecognized speech and other potential issues during the recognition process.


## `get_response()` Function
### Summary of this function --> [summary](#summary-16)
```python
    # Initialize an empty history (using a list) to maintain conversation context
    history = []

    # Define a function to get a response from the RRB BOT based on the user's input
    def get_response(user_input):
        time.sleep(2) 
        chat_session = model.start_chat(history=history)
        response = chat_session.send_message(user_input)
        model_response = response.text
        history.append({"role": "user", "parts": [user_input]})
        history.append({"role": "model", "parts": [model_response]})
        return model_response
```

#### `history = []`
This initializes an empty list (`history`) that will be used to store the conversation context. The history will hold the user's inputs and the bot's responses, enabling the bot to maintain context across multiple exchanges.

#### `def get_response(user_input):`
This function takes the user's input (`user_input`) as a parameter and generates a response based on that input. It interacts with the `model` to get the appropriate reply from the bot.

#### `chat_session = model.start_chat(history=history)`
The `start_chat()` method is called on the `model` to begin a new chat session. The `history` parameter is passed to maintain the conversation context from previous interactions. This ensures that the model has access to the prior messages when generating the new response.

#### `response = chat_session.send_message(user_input)`
This sends the user's input to the model and waits for the response. The message is processed by the model and stored in the `response` variable.

#### `model_response = response.text`
Once the response is generated, the `text` attribute of the `response` object contains the model's reply. This is stored in the `model_response` variable.

#### `history.append({"role": "user", "parts": [user_input]})`
The user's input is added to the conversation history with a role of `"user"`. This helps keep track of the user's part of the conversation.

#### `history.append({"role": "model", "parts": [model_response]})`
The bot's response is added to the conversation history with a role of `"model"`. This ensures that the model's responses are also recorded and can be used in future messages.

#### `return model_response`
Finally, the function returns the model's response (`model_response`), which can be used to display the bot's reply or perform further actions.

### Summary
- The `get_response` function is responsible for handling user inputs and generating responses from the RRB bot.
- It maintains the conversation context using the `history` list, which tracks both the user’s inputs and the bot's replies.
- By starting a chat session with the `model` and sending the user's input, the function retrieves a response and adds both the user's message and the bot's reply to the history.
- This setup ensures that the bot can keep track of previous exchanges, making its responses updated all the time.

## `update_chat()` Function
### Summary of this function --> [summary](#summary-17)
```python
    # Define a function to update the chat window with new messages
    def update_chat(message):
        chat_window.configure(state='normal') 
        chat_window.insert(END, message + '\n')  
        chat_window.configure(state='disabled')  
        chat_window.yview(END)  
        chat_window.update_idletasks()  # Force the update to show immediately
```

#### `chat_window.configure(state='normal')`
This line temporarily sets the chat window's state to `'normal'` so that it can be modified (text can be inserted). By default, the chat window might be in a `'disabled'` state to prevent user edits, so this line unlocks it for modification.

#### `chat_window.insert(END, message + '\n')`
The `insert()` method adds the `message` at the end of the chat window's content. The `END` constant ensures the message is appended to the last position in the window. The `\n` adds a newline to ensure that each message is displayed on a new line.

#### `chat_window.configure(state='disabled')`
Once the message is added, the chat window is set back to `'disabled'` to prevent further user edits. This ensures that the chat content remains read-only for the user (maintaining the appearance of a conversation)

#### `chat_window.yview(END)`
This command ensures that the view of the chat window scrolls to the most recent message. By setting the view to `END`, it scrolls to the bottom so that the latest message is visible to the user.

#### `chat_window.update_idletasks()`
This method forces the chat window to immediately update and reflect the changes made by the previous commands. It ensures that the new message is shown without delay.

### Summary
- The `update_chat` function updates the chat window with a new message each time it is called.
- It unlocks the chat window temporarily to insert the message, adds the message at the end of the chat, then locks the window again.
- The function ensures that the chat window always scrolls to the latest message (providing a smooth and real-time conversation experience for the user)

## `speak()` Function
### Summary of this function --> [summary](#summary-18)

```python
    # Define a function to speak the provided text using gTTS (Google Text-to-Speech) library
    def speak(text, lang='th'):
        tts = gTTS(text=text, lang=lang)

        # Create a temporary file for the speech audio
        temp_file_path = None
        try:
            # Save the generated speech as an MP3 file
            with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as temp_file:
                temp_file_path = temp_file.name
                tts.save(temp_file_path)

            # Initialize the pygame mixer to play the audio
            pygame.mixer.init()

            # Ensure the file exists and is loaded properly
            if os.path.exists(temp_file_path):
                pygame.mixer.music.load(temp_file_path)
                pygame.mixer.music.play()

                # Wait for the audio to finish playing
                while pygame.mixer.music.get_busy():
                    time.sleep(0.1)
            else:
                update_chat("Error: Audio file not found. Please try again")
                print("Error: Audio file not found. Please try again")
            
        except pygame.error as e:
            update_chat(f"Error playing audio: {e} Please try again")
            print(f"Error playing audio: {e} Please try again")

        finally:
            # Quit pygame mixer to release resources
            pygame.mixer.quit()

            # Clean up by removing the temporary audio file
            if temp_file_path and os.path.exists(temp_file_path):
                time.sleep(0.5)  # Ensure the file is not in use before deletion
                os.remove(temp_file_path)
```

#### `tts = gTTS(text=text, lang=lang)`
Generates speech from the provided `text` in the specified `lang` (default is Thai, `'th'`).

#### `with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as temp_file:`
Creates a temporary file with an `.mp3` extension to store the generated speech audio. The file is not deleted automatically (`delete=False`) when it is closed, allowing further use of the file.

#### `tts.save(temp_file_path)`
Saves the generated speech as an MP3 file in the temporary file path.

#### `pygame.mixer.init()`
Initializes the `pygame.mixer` module, which is used to play audio.

#### `if os.path.exists(temp_file_path):`
Checks whether the temporary file exists before attempting to load and play it.

#### `pygame.mixer.music.load(temp_file_path)`
Loads the MP3 file into the `pygame.mixer.music` player.

#### `pygame.mixer.music.play()`
Plays the loaded audio.

#### `while pygame.mixer.music.get_busy():`
Keeps the program waiting until the audio has finished playing. The loop continues while the music is still playing.

#### `update_chat("Error: Audio file not found. Please try again")`
If the temporary audio file does not exist, an error message is displayed in the chat window, and an error message is printed.

#### `except pygame.error as e:`
Handles errors that may occur during audio playback, such as issues with the `pygame.mixer` module. The error message is displayed in the chat.

#### `pygame.mixer.quit()`
Stops and releases the `pygame.mixer` module, ensuring resources are all out after the audio has finished playing.

#### `if temp_file_path and os.path.exists(temp_file_path):`
Checks if the temporary file exists and removes it after use to clean up.

#### `time.sleep(0.5)`
Adds a slight delay before deleting the file to ensure that it is not in use during the deletion process.

#### `os.remove(temp_file_path)`
Deletes the temporary audio file from the system.

### Summary
- The `speak()` function converts text to speech using `gTTS` and plays it with `pygame.mixer`.
- It creates a temporary `.mp3` file for the speech, plays it, and cleans up afterward by deleting the file.
- The function includes error handling for missing files or playback issues, displaying appropriate messages in the chat and console.
- Once the playing of the audio file is over then it will be deleted.

## `is_thai()` Function
### Summary of this function --> [summary](#summary-19)
```python
    # Checks if the text contains Thai characters
    def is_thai(text):
        return bool(re.fullmatch('[\u0E00-\u0E7F\\s]+', text))
```

#### `return bool(re.fullmatch('[\u0E00-\u0E7F\\s]+', text))`
This line uses a regular expression to match the text against a pattern that represents Thai characters. Here's how it works:
- `[\u0E00-\u0E7F]`: This is a Unicode range that covers all `Thai characters`, from `\u0E00` to `\u0E7F`.
- `\\s`: Matches any `whitespace character` like spaces.
- `+`: Ensures that one or more characters in the string match the pattern.
- `re.fullmatch()`: This function tries to match the entire string (`text`) to the given regular expression pattern. It returns a match object if the whole string consists only of Thai characters and whitespace, and `None` if otherwise.
- `bool()`: Converts the result of `re.fullmatch()` to a boolean. If the match is successful, it returns `True`; otherwise, it returns `False`.

### Summary
- The `is_thai` function checks if a given string contains only Thai characters and whitespace using the regular expression library.
- It returns `True` if the text matches the pattern for Thai characters, otherwise `False`.

## `is_english_only()` Function
### Summary of this function --> [summary](#summary-20)
```python
    # Checks if the text contains English characters
    def is_english_only(text):
        return bool(re.fullmatch(r'^[A-Za-z0-9\s,\.!?;:()"\']+$', text))
```

#### `return bool(re.fullmatch(r'^[A-Za-z0-9\s,\.!?;:()"\']+$', text))`
This line uses a regular expression to match the text against a pattern that represents English characters and certain punctuations. Here's how it works:
- `^[A-Za-z0-9\s,\.!?;:()"\']+$`: This is the regular expression pattern used to match English characters and common punctuation.
  - `A-Za-z`: Matches any lowercase (`a-z`) or uppercase (`A-Z`) English letters.
  - `0-9`: Matches any digit.
  - `\s`: Matches any whitespace character like spaces.
  - `,\.!?;:()"\']`: Matches any punctuations.
  - `+`: Ensures that one or more of the allowed characters appear in the string.
  - `^`: Asserts that the pattern must match from the beginning of the string.
  - `$`: Asserts that the pattern must match to the end of the string.
- `re.fullmatch()`: This function checks if the entire string (`text`) matches the pattern. It returns a match object if the whole string consists only of the allowed characters and punctuation, and `None`if otherwise.
- `bool()`: Converts the result of `re.fullmatch()` to a boolean. If the match is successful, it returns `True`; otherwise, it returns `False`.

### Summary
- The `is_english_only` function checks if a given string contains only English letters (both lowercase and uppercase), digits, spaces, and a set of common punctuation marks using the regular expression library.
- It returns `True` if the text matches the pattern, otherwise `False`.

## `is_mixed_language()` Function
### Summary of this function --> [summary](#summary-21)
```python
    # Check if the text contains both English and Thai characters
    def is_mixed_language(text):
        has_thai = bool(re.search('[\u0E00-\u0E7F]', text))
        has_english = bool(re.search('[A-Za-z]', text))
        
        return has_thai and has_english  # Returns True if both Thai and English are found
```

#### `has_thai = bool(re.search('[\u0E00-\u0E7F]', text))`
This line uses a regular expression to check if the text contains any Thai characters:
- `[\u0E00-\u0E7F]`: This range represents the Unicode characters for Thai script (Unicode -> from U+0E00 to U+0E7F).
- `re.search()`: This function searches the text for the specified pattern. If any Thai character is found, it returns a match object; otherwise, it returns `None`.
- `bool()`: Converts the result of `re.search()` to a boolean. It will be `True` if a Thai character is found, and `False` otherwise.

#### `has_english = bool(re.search('[A-Za-z]', text))`
This line uses a regular expression to check if the text contains any English alphabet characters:
- `[A-Za-z]`: This range represents all English letters, both lowercase (`a-z`) and uppercase (`A-Z`).
- `re.search()`: This function searches the text for the specified pattern. If any English letter is found, it returns a match object; otherwise, it returns `None`.
- `bool()`: Converts the result of `re.search()` to a boolean. It will be `True` if an English letter is found, and `False` otherwise.

#### `return has_thai and has_english`
This line returns `True` if both Thai and English characters are found in the text (`has_thai` and `has_english` are both `True`). If either one is `False`, it returns `False`.

### Summary
- The `is_mixed_language` function checks if a given text contains both Thai and English characters by searching for characters in both language ranges using regular expressions.
- It returns `True` if both Thai and English characters are found in the text, otherwise `False`.

## `toggle_language()` Function
### Summary of this function --> [summary](#summary-22)
```python
    # Function to toggle between English and Thai language modes
    def toggle_language(event=None):
        global language
        # Switch the language
        if language == "en":
            language = "th"
        else:
            language = "en" 
        # Show a message indicating the language change 
        if language == "th":
            lang_message = "Language switched to Thai."
            history.append({"role": "user", "parts": ["Switching to Thai."]})
            history.append({"role": "model", "parts": ["ตอนนี้ฉันต้องเปลี่ยนเป็นพูดภาษาไทย"]})
        else:
            lang_message = "Language switched to English."
            history.append({"role": "user", "parts": ["Switching to English."]})
            history.append({"role": "model", "parts": ["I will now speak English."]})
            
        update_chat(lang_message)
        speak(lang_message, lang=language)
```

#### `global language`
The `language` variable is declared as a global variable so that it can be modified within this function and reflect changes across the entire application.

#### `if language == "en":`
Checks if the current language is English. If true, it switches the language to Thai.

#### `language = "th"`
Sets the `language` variable to `'th'` (Thai).

#### `else:`
If the current language is not English (it means that its set to Thai), the function switches it to English.

#### `language = "en"`
Sets the `language` variable to `'en'` (English).

#### `if language == "th":`
If the language is now set to Thai, the message informing the user about the switch is created in Thai.

#### `lang_message = "Language switched to Thai."`
Sets the message indicating the language has switched to Thai.

#### `history.append({"role": "user", "parts": ["Switching to Thai."]})`
Appends the user's action of switching to Thai to the conversation history.

#### `history.append({"role": "model", "parts": ["ตอนนี้ฉันต้องเปลี่ยนเป็นพูดภาษาไทย"]})`
Appends the model's response in Thai, indicating that it will now speak Thai.

#### `else:`
If the language is switched to English, the message informing the user about the change is set in English.

#### `lang_message = "Language switched to English."`
Sets the message indicating the language has switched to English.

#### `history.append({"role": "user", "parts": ["Switching to English."]})`
Appends the user's action of switching to English to the conversation history.

#### `history.append({"role": "model", "parts": ["I will now speak English."]})`
Appends the model’s response in English, stating that it will now speak English.

#### `update_chat(lang_message)`
Updates the chat window with the message indicating the language switch.

#### `speak(lang_message, lang=language)`
Speaks the message aloud using the [speak()](#speak-function) function, adjusting the language setting based on the current mode (either Thai or English).

### Summary
- The `toggle_language` function switches between English and Thai language modes.
- It updates both the conversation history and the chat window to reflect the language change.
- The function ensures that the bot responds in the new language and speaks the corresponding message to the user.

## `exit_program()` Function
### Summary of this function --> [summary](#summary-23)
```python
     # Function to exit the program when the user presses the exit key
    def exit_program(event=None):
        root.quit()  # Close the Tkinter window
        os._exit(0)  # Exit the program immediately
```

#### `root.quit()`
This method is called to terminate the Tkinter event loop, effectively closing the application window.

#### `os._exit(0)`
This function immediately exits the Python program. The argument `0` indicates a successful termination without errors.

### Summary
- The `exit_program` function allows the user to exit the application by triggering the exit event (by pressing the `q` button)
- It closes the Tkinter window and forces the program to terminate immediately using `os._exit(0)`.

## `create_table()` Function
### Summary of this function --> [summary](#summary-24)
```python
    def create_table():
        # Connecting to the sqlite3 database
        conn = sqlite3.connect('accounts.db')
        c = conn.cursor()
        
        # Create table query
        c.execute("""CREATE TABLE IF NOT EXISTS all_accounts (
                    username TEXT,
                    password TEXT
                    )""")
        
        # Commit the changes and close the connection
        conn.commit()
        conn.close()
        print("Table \"all_accounts\" created successfully!")

    # Call the function to create the table and then close the call function with a comment
    # create_table()
```

#### `conn = sqlite3.connect('accounts.db')`
Establishes a connection to the SQLite database named `accounts.db`. If the database does not exist, it will be created automatically.

#### `c = conn.cursor()`
Creates a cursor object `c`, which allows you to interact with the database by executing SQL queries.

#### `c.execute("""CREATE TABLE IF NOT EXISTS all_accounts (...)""")`
This SQL query creates a new table named `all_accounts` with two columns: `username` and `password`. The `IF NOT EXISTS` clause ensures the table is only created if it doesn't already exist, preventing errors if the table is already present.

#### `conn.commit()`
Commits the transaction to the database, saving the changes (the creation of the table).

#### `conn.close()`
Closes the connection to the database after the changes have been committed.

#### `print("Table \"all_accounts\" created successfully!")`
Prints a success message to indicate the table has been created successfully in the terminal.

### Summary
- The `create_table()` function connects to an SQLite database and creates a table named `all_accounts` if it doesn't exist.
- The table contains two fields: `username` and `password`.
- The function then commits the changes and closes the database connection.
- The success message confirms that the table was created successfully.













